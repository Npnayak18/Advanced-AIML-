import numpy as np

def sigmoid(x):
    return 1 / (1 + np.exp(-x))

def sigmoid_deriv(x):
    return x * (1 - x)

X = np.array([[0,0],[0,1],[1,0],[1,1]], dtype=float)
y = np.array([[0],[1],[1],[0]], dtype=float)

np.random.seed(0)
w1 = np.random.randn(2,4)
b1 = np.zeros((1,4))
w2 = np.random.randn(4,1)
b2 = np.zeros((1,1))

lr = 0.1
epochs = 10000

for _ in range(epochs):
    z1 = X @ w1 + b1
    a1 = sigmoid(z1)
    z2 = a1 @ w2 + b2
    a2 = sigmoid(z2)

    loss = np.mean((y - a2) ** 2)

    da2 = 2 * (a2 - y) / y.shape[0]
    dz2 = da2 * sigmoid_deriv(a2)
    dw2 = a1.T @ dz2
    db2 = np.sum(dz2, axis=0, keepdims=True)

    da1 = dz2 @ w2.T
    dz1 = da1 * sigmoid_deriv(a1)
    dw1 = X.T @ dz1
    db1 = np.sum(dz1, axis=0, keepdims=True)

    w2 -= lr * dw2
    b2 -= lr * db2
    w1 -= lr * dw1
    b1 -= lr * db1

print("Input:\n", X)
print("Predicted:\n", (a2 > 0.5).astype(int))
